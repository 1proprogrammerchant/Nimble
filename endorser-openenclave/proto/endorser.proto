syntax = "proto3";

package endorser_proto;

service EndorserCall {
  // Protocol Endpoints
  rpc GetPublicKey(GetPublicKeyReq) returns (GetPublicKeyResp);
  rpc InitializeState(InitializeStateReq) returns (InitializeStateResp);
  rpc NewLedger(NewLedgerReq) returns (NewLedgerResp);
  rpc ReadLatest(ReadLatestReq) returns (ReadLatestResp);
  rpc Append(AppendReq) returns (AppendResp);
  rpc AppendViewLedger(AppendViewLedgerReq) returns (AppendViewLedgerResp);
  rpc ReadLatestState(ReadLatestStateReq) returns (ReadLatestStateResp);
  rpc Unlock(UnlockReq) returns (UnlockResp);
}

message GetPublicKeyReq {
}

message GetPublicKeyResp {
  bytes pk = 1;
}

message NewLedgerReq {
  bytes handle = 1;
  bytes block_hash = 2;
  bool ignore_lock = 3;
}

message NewLedgerResp {
  bytes receipt = 1;
}

message ReadLatestReq {
  bytes handle = 1;
  bytes nonce = 2;
  uint64 expected_height = 3;
}

message ReadLatestResp {
  bytes receipt = 1;
}

message AppendReq {
  bytes handle = 1;
  bytes block_hash = 2;
  uint64 expected_height = 3;
  bool ignore_lock = 4;
}

message AppendResp {
  bytes receipt = 1;
}

message AppendViewLedgerReq {
  bytes block_hash = 1;
  uint64 expected_height = 2;
}

message AppendViewLedgerResp {
  bytes receipt = 1;
}

message LedgerTailMapEntry {
  bytes handle = 1;
  bytes metablock = 2;
}

// protobuf supports maps (https://developers.google.com/protocol-buffers/docs/proto#maps), 
// but it does not allow using bytes as keys in the map
// gRPC messages are limited to 4 MB, which allows about 50+K entries. 
// In the future, we can either increase the limit on gRPC messages or switch to gRPC streaming 
message InitializeStateReq {
  repeated LedgerTailMapEntry ledger_tail_map = 1; // the list of ledger tails
  bytes view_tail_metablock = 2; // the view ledger tail's metablock
  bytes block_hash = 3; // the block hash of the latest block on the view ledger
  uint64 expected_height = 4; // the conditional updated height of the latest block on the view ledger
}

message InitializeStateResp {
  bytes receipt = 1;
}

message ReadLatestStateReq {
  bool to_lock = 1;
}

message ReadLatestStateResp {
  repeated LedgerTailMapEntry ledger_tail_map = 1; // the list of ledger tails
  bytes view_tail_metablock = 2; // the view ledger tail's metablock
}

message UnlockReq {
}

message UnlockResp {
}